<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>C++ R Engine: Refactoring History</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya" />
</head>

<body>
<h1>C++ R Engine: Refactoring History</h1>

<p>This document describes the phases within the CXXR project to refactor the
R engine into C++. Each phase is placed within the Subversion
<code>tags</code> directory, with a name of the form <code>0.00-2.5.0</code>,
where <code>0.00</code> indicates the phase, and <code>2.5.0</code> indicates
the R release to which that phase is intended to correspond.</p>

<h2>Phase 0: <code>0.00-2.5.0</code></h2>

<p>In this phase all <code>.cpp</code> files within <code>src/main</code> are
renamed to <code>.cpp</code>, with the following exceptions:</p>
<ul>
  <li><code>complex.c</code>: This file uses the C99 complex types, which are
    not understood by a C++ compiler;</li>
  <li><code>gram.c</code>: This file is automatically generated by
  yacc/bison;</li>
  <li><code>regex.c</code>: The source of this file is very insistent that it
    is C, not C++: it gives a #warning if you attempt to compile it with a
    C++ compiler.</li>
</ul>

<p>The result of this phase does not build correctly; however, it is useful
as a baseline for seeing the subsequent changes.</p>

<h2>Phase 1: <code>0.01-2.5.0</code></h2>

<p>Make such changes to the result of Phase 0 to enable the <code>.cpp</code>
files to compile without warning using <code>-Wall</code> with
<code>gcc-4.1.3</code>, retaining C linkage conventions for everything
defined in <code>.h</code> files. Ensure that the whole of R will build
correctly and pass <code>make check</code>.</p>

<p>A desirable side effect of enforcing C linkage was that the linkage editor
picked up several instances where the source file implementing a function
failed to <code>#include</code> the appropriate header file, and consequently
generated a function with C++ linkage: see below.</p>

<p>This needed to address the following issues:</p>
<ul>
  <li><code>Rboolean</code> is different from C++ <code>bool</code>.
    <code>Rboolean</code> is an enumeration with elements
    <code>FALSE=0</code> and <code>TRUE=1</code>; <code>bool</code> is a
    primitive type, with values <code>false</code> and <code>true</code>.
    (Also, there are <code>#define</code>s of <code>FALSE</code> to 0 and
    TRUE to 1 lurking around in the R code, just to confuse matters.) In
    particular an <code>Rboolean</code> is a different size from a
    <code>bool</code>. It was necessary to introduce many explicit
    conversions from <code>bool</code> (resulting in C++ from evaluating
    Boolean expressions) or integer types to <code>Rboolean</code>. 
    <p>In connection with this, defined a macro <code>RBOOL(x)</code> within
    <code>Rinlinedfuns.h</code> expands to <code>x</code> in C and
    <code>Rboolean(x)</code> in C++.</p>
  </li>
  <li>The C++ keywords <code>class</code>, <code>new</code>,
    <code>private</code> and <code>this</code> were used as identifiers;
    these had to be renamed, e.g. <code>class</code> changed to
    <code>connclass</code>.</li>
  <li>In various places, particularly <code>connections.cpp</code>, a
    <code>void*</code> was implicitly converted to another type of pointer.
    These conversions were made explicit, and flagged
  <code>/*CCAST*/</code>.</li>
  <li><code>datetime.cpp</code> and <code>memory.cpp</code> used statements
    of the form <code>i -= d;</code> where <code>i</code> is of integer type
    and <code>d</code> is an expression evaluating to a floating point type.
    This was converted to the form <code>i = int(i - (d));</code> to avoid a
    compiler warning. This interpretation complies with sec. 6.5.12.2 of the
    C99 standard <a
    href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf">ISO:IEC
    9899:1999</a>.</li>
  <li>The structure type <code>NewDevDesc</code> defined in
    <code>GraphicsDevice.h</code> contains a number of pointers to functions
    as members, and the types of these functions were specified without
    giving the number and types of the function arguments. This was
    rectified. It was also necessary to give this structure a tag
    (<code>_NewDevDesc</code>) because most of these functions included a
    pointer to a <code>NewDevDesc</code> among their arguments.</li>
  <li>It was necessary to shift some of the material in
    <code>R_ext/GraphicsEngine.h</code>, in particular the definition of
    <code>R_GE_context</code>, into a new header file
    <code>R_ext/GraphicsContext.h</code>, to avoid reciprocal dependencies
    between <code>GraphicsEngine.h</code> and
  <code>GraphicsDevice.h</code>.</li>
  <li>The pointer to function type <code>CCODE</code>, defined in
    <code>Defn.h</code>, was redefined to make the number and type of its
    arguments explicit, as follows: 
    <pre>typedef SEXP (*CCODE)(SEXP, SEXP, SEXP, SEXP);</pre>
  </li>
  <li>If <code>__MAIN__</code> is defined, <code>libextern.h</code>
    <code>#define</code>d <code>extern</code> to the empty string, which
    could play havoc with the <code>extern "C"</code> used in C++ to enforce
    C-style linkage. This <code>#define</code> was commented out, and instead
    a new macro <code>extern1</code> was <code>#define</code>d within
    <code>Defn.h</code>.</li>
  <li>In numerous places it was necessary to make conversions from
    floating-point types to integer types explicit. In other places it was
    clear that the same effect could be achieved without deleterious side
    effect by changing the type of a variable.</li>
  <li>It was necessary to introduce <code>reinterpret_cast</code>s in various
    places in <code>memory.cpp</code>, <code>scan.cpp</code>,
    <code>serialize.cpp</code> and <code>vfonts.cpp</code>. (In future it is
    the intention to get rid of as many of these as possible, as well as
    getting rid of all C-style casts.)</li>
  <li>In <code>Defn.h</code>, the whole declaration <code>extern FUNTAB
    R_FunTab[];</code> was made <code>#ifndef __R_Names__</code>, not just
    the word <code>extern</code>.</li>
  <li>In some places I couldn't resist changing the type of a function
    argument from a plain pointer to a <code>const</code> pointer. We can
    expect much more of this later, but this may have been premature.</li>
  <li><code>sysutils.cpp</code> (conditionally) contained an
    <code>extern</code> declaration of <code>environ</code>; the compiler
    considered this to have C++ linkage, conflicting with the C-linkage
    definition in <code>unistd.h</code> (subsequently <code>#include</code>d
    into <code>sysutils.cpp</code>). This <code>extern</code> declaration has
    been itself replaced by a (conditional) <code>#include</code> of
    <code>unistd.h</code>.</li>
  <li>Sorted out problems where a file implementing a function failed to
    include the relevant header file. In some cases this was because the
    prototype didn't appear in <em>any</em> header file, and clients of the
    function were instead relying on a prototype within the client source
    file itself! Such misplaced prototypes were found in
    <code>eval.cpp</code>, <code>format.cpp</code>, <code>memory.cpp</code>,
    <code>platform.cpp</code>, <code>printutils.cpp</code>, and
    <code>library/methods/src/methods_list_dispatch.c</code>; they were
    commented out, and flagged with the comment "Use header files!". Needed
    prototypes that didn't appear in any header file were generally placed at
    the end of <code>Defn.h</code>. 
    <p>A particularly obscure example of this kind concerns
    <code>R_CHAR</code>. This is declared as a pointer to a function in
    <code>Rinternals.h</code>, and implemented in <code>memory.cpp</code>.
    Now <code>memory.cpp</code> does <code>#include</code>
    <code>Rinternals.h</code>, but it does so with
    <code>USE_RINTERNALS</code> defined, as a result of which the
    <code>R_CHAR</code> declaration in the header file isn't seen by the
    compiler, and so the implemented function got C++ linkage. I modified the
    header file by moving the <code>R_CHAR</code> declaration outside the
    <code>#ifndef USE_RINTERNALS</code>.</p>
  </li>
  <li>The definitions in <code>print.cpp</code> of functions intended to be
    called from FORTRAN needed to be surrounded by <code>extern "C"{</code>
    ... <code>}</code>.</li>
  <li><code>deparse.cpp</code>:1191 used <code>&amp;</code> where
    <code>&amp;&amp;</code> was surely intended;
    <code>character.cpp</code>:738 similarly used <code>|</code> instead of
    <code>||</code>.</li>
  <li><code>-Wall</code> complains about attempts to compare signed with
    unsigned. This required explicit conversions in numerous places.
    Generally (but not always) I did this by converting unsigned to signed.
    In other places it was clear that the same effect could be achieved
    without deleterious side effect by changing the type of a variable. 
    <p>In connection with this, the macro <code>AGE_NODE</code> in
    <code>memory.cpp</code> had to be changed to make <code>an__g__</code>
    unsigned.</p>
  </li>
</ul>

<h2>Phase 2: <code>0.02-2.5.0</code></h2>

<p>In a subsequent phases (possibly starting in Phase 3) it is our objective
to replace the SEXPREC union by a hierarchy of C++ classes. This phase
prepares for that by reorganising the material in the header files in
<code>src/include</code>. This involves creating a new subdirectory
<code>src/include/CXXR</code>, and within that creating a new header file
<code>RObject.h</code> (ultimately to include a base class
<code>RObject</code> for the new hierarchy), and further header files
<code>RClosure.h</code>, <code>REnvironment.h</code>,
<code>RInternalFunction.h</code>, <code>RPairList.h</code>,
<code>RPromise.h</code>, <code>RSymbol.h</code> and <code>RVector.h</code>,
corresponding respectively to <code>closxp_struct</code>,
<code>envsxp_struct</code>, <code>primsxp_struct</code>,
<code>listsxp_struct</code>, <code>promsxp_struct</code>,
<code>symsxp_struct</code> and <code>vecsxp_struct</code>, which will
eventually be derived classes. The material in these new headers comes
predominantly from <code>Rinternals.h</code>, but to some extent (in the case
of <code>RInternalFunction.h</code>) from <code>Defn.h</code>. All of the new
header files, with the exception of <code>RInternalFunction.h</code>, are
also installed in <code>$(rincludedir)/CXXR</code>.</p>

<p>Function prototypes moved into the new header files are documented using
<a href="http://www.doxygen.org">doxygen</a>. Where is was clearly consistent
with the semantics, some of the argument types of the functions were changed,
either by adding <code>const</code>, or by converting <code>int</code> into
<code>Rboolean</code> (however, see the issues below regarding the
latter).</p>

<p>The following are implementational details and issues that arose:</p>
<ul>
  <li>The implementation of SEXPREC (though still the unchanged C code) was
    made visible only to C++ programs. This is to get advance warning of
    potential problems when the implementation <em>is</em> changed to
  C++.</li>
  <li>In many places CR defined a name as a macro when
    <code>USE_RINTERNALS</code> was defined, and otherwise as a function. It
    has been the intention in this phase to replace the macros with C++
    inline functions: these would automatically also generate a non-inlined
    form, so the separate definition (usually in <code>memory.cpp</code>)
    could be dispensed with. 
    <p>This was all very well where the function form was implemented in CR
    simply by invoking the macro; however in some cases the function form
    carried out some error checking before invoking the macro. Trying to
    convert the macro to an inline function would then result in two distinct
    functions with the same name, which the compiler and/or linker would
    certainly reject.</p>
    <p>In the end it was decided to leave the macros in place for the time
    being: they'll have to be changed when the C++ implementation rolls out
    anyway.</p>
  </li>
  <li>I considered getting rid of the <code>USE_RINTERNALS</code> compilation
    conditions, but decided to retain it to mark out material (usually
    currently in the form macro definitions) that will in the future need
    privileged access to a C++ class. Only <code>memory.cpp</code> now
    <code>#define</code>s <code>USE_RINTERNALS</code>.</li>
  <li><code>Rinternals.h</code> contained many <code>#define</code>s of
    function names to the same name prefixed by <code>Rf_</code>: this
    appears to correspond in C++ terms to putting these functions in a
    namespace. I split these <code>#define</code>s out into a separate header
    file <code>Rf_namespace.h</code>, which is <code>#include</code>d by
    <code>RObject.h</code> (which is in turn included by the other new
    headers). There are various similar <code>#define</code>s scattered
    around other CR header files, which may need to be moved into
    <code>Rf_namespace.h</code> in due course.</li>
  <li>I dithered about whether to name the file in question
    <code>RInternalFunction.h</code> or <code>RPrimitiveFunction.h</code>.
    Usage in the CR code (e.g. primsxp_struct) suggests the latter, and the R
    Internals document speaks of internal and primitive functions as being
    mutually exclusive, but fails to give a more general name covering any
    function handled via <code>R_FunTab</code>. But it seems to be reasonable
    to regard primitive functions as a special case of an internal function,
    hence the eventual choice of <code>RInternalFunction.h</code>.</li>
  <li>It is noted that <code>Rdynload.cpp</code> and <code>dotcode.cpp</code>
    each give compiler warnings under <code>-pedantic</code> because they
    attempt to cast function pointers to <code>void*</code>. The source code
    of the former already contains a comment saying that it's illegal even in
    C. Not easy to fix, so leave for now.</li>
  <li>It seems logical (!) that a logical vector (<code>LGLSXP</code>) should
    contain items of type <code>Rboolean</code> rather than of type
    <code>int</code>, and consequently that the macro/function
    <code>LOGICAL(SEXP)</code> should return <code>Rboolean*</code> rather
    than <code>int*</code>. I made some attempt to do this, but backed out of
    it for the following reasons: 
    <ul>
      <li>The <code>.C</code> interface expects these vectors to contain
        <code>int</code>s;</li>
      <li>ISO14882:1998 says that in C++, subject to certain constraints, it
        is implementation-defined which integral type is used as the
        underlying type for an enumeration (though <code>gcc</code> happens
        to use <code>int</code> for <code>Rboolean</code>).</li>
      <li>ISO9899:1999 says much the same for C, but with differently worded
        constraints.</li>
      <li>In any case, despite the commented-out <code>MAYBE</code> value in
        the enumeration, perhaps <code>Rboolean</code> is best thought of as
        '<code>bool</code> for C', rather than having any capability to
        handle NAs.</li>
    </ul>
    <p>Possible new policy: within functions visible from C, use
    <code>Rboolean</code> as a substitute for C++ <code>bool</code>, possibly
    constrained to be 32 bits long to avoid the <code>enum</code>
    implementation dependencies noted above. However, R logical vectors will
    continue to be represented using <code>int</code>s. (One day we might
    define an <code>Rlogical</code> class - a wrapper round an
    <code>int</code> - to handle logical vectors within C++, while C programs
    simply see <code>typedef int Rlogical;</code>.)</p>
  </li>
</ul>
</body>
</html>
